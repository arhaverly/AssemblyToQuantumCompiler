\begin{abstract}
The Maximum Common Subgraph (MCS) problem is a fundamental problem in graph theory, which has significant applications in various domains, such as cheminformatics and computer vision. Given two graphs, the objective of the MCS problem is to find the largest subgraph that is isomorphic to both input graphs. Due to its NP-hard nature, researchers have been exploring various heuristics, approximation algorithms, and exact methods for solving the MCS problem. Recently, quantum computing has emerged as a promising paradigm for tackling complex computational tasks. In this paper, we present a novel approach to solve the MCS problem using Grover's algorithm, a well-known quantum search algorithm capable of speeding up unstructured search tasks. We provide a detailed description of the proposed method, demonstrate its feasibility, and analyze its potential performance gains over classical approaches. The results of our work show that leveraging quantum computing techniques, particularly Grover's algorithm, can significantly improve the efficiency of solving the MCS problem, potentially benefiting various applications in different domains.
\end{abstract}

\section{Introduction}

The Maximum Common Subgraph (MCS) problem is a well-studied combinatorial optimization problem in graph theory. Given two graphs $G_1$ and $G_2$, the goal of the MCS problem is to find the largest subgraph that is isomorphic to both input graphs. The MCS problem has various applications in diverse domains, including cheminformatics \cite{raymond2002maximum}, pattern recognition \cite{bunke1997graph}, and computer vision \cite{conte2004thirty}. Due to its significance in practical applications, the MCS problem has received substantial attention from the research community.

However, the MCS problem is known to be NP-hard \cite{garey1979computers}, which means that finding an efficient algorithm to solve it in the worst case is unlikely. As a result, researchers have proposed several heuristics, approximation algorithms, and exact methods for solving the MCS problem. Some of these methods include backtracking algorithms \cite{mcgregor1982backtrack}, clique-based algorithms \cite{bron1973algorithm}, maximum clique enumeration \cite{akutsu2007approximation}, and constraint programming \cite{solnon2010all}. While these classical techniques have been successful in solving the MCS problem to varying degrees, they often suffer from high computational complexity, particularly for large and dense graphs.

In recent years, quantum computing has emerged as a promising paradigm for solving complex computational tasks. Quantum computing exploits the principles of quantum mechanics to perform computations, offering the potential to solve problems that are intractable for classical computers. One of the key quantum algorithms is Grover's algorithm \cite{grover1996fast}, which provides a quadratic speedup for unstructured search tasks. Grover's algorithm has been applied to various combinatorial optimization problems, such as the traveling salesman problem \cite{daskin2012quantum} and the knapsack problem \cite{han2017quantum}. However, the application of Grover's algorithm to the MCS problem has not been explored in-depth.

In this paper, we present a novel approach for solving the MCS problem using Grover's algorithm. We provide a detailed description of the proposed method, which leverages the powerful search capabilities of Grover's algorithm to efficiently explore the solution space of the MCS problem. The key contributions of our work are as follows:

\begin{itemize}
    \item We propose a novel quantum algorithm for solving the MCS problem based on Grover's algorithm, which offers a potential quadratic speedup over classical approaches.
    
    \item We present a comprehensive description of the proposed method, including the encoding of the MCS problem into a binary search space, the design of a suitable oracle function, and the integration of Grover's algorithm for efficient search.
    
    \item We conduct a theoretical analysis of the performance of our proposed algorithm, demonstrating its potential gains over classical approaches and its feasibility for solving the MCS problem in practice.
\end{itemize}

The remainder of this paper is organized as follows. In Section \ref{sec:background}, we provide a brief overview of the background concepts required to understand our proposed algorithm, including the MCS problem, quantum computing, and Grover's algorithm. In Section \ref{sec:proposed_algorithm}, we present the details of our proposed quantum algorithm for solving the MCS problem, including the problem encoding, oracle function design, and search procedure using Grover's algorithm. In Section \ref{sec:analysis}, we analyze the performance of our proposed algorithm, comparing it to classical approaches and discussing its potential benefits and limitations. Finally, we conclude the paper and outline future research directions in Section \ref{sec:conclusion}.

\section{Background}
\label{sec:background}

In this section, we provide an overview of the necessary background concepts for understanding our proposed quantum algorithm for the MCS problem, including a description of the MCS problem, quantum computing, and Grover's algorithm.

\subsection{Maximum Common Subgraph Problem}

The Maximum Common Subgraph (MCS) problem is a fundamental problem in graph theory, with significant applications in various domains. Formally, given two graphs $G_1=(V_1, E_1)$ and $G_2=(V_2, E_2)$, the objective of the MCS problem is to find the largest subgraph $H=(V_H, E_H)$ that is isomorphic to both input graphs, i.e., there exists a bijective function $f: V_H \rightarrow V_{G_1}$ such that $(u,v) \in E_H$ if and only if $(f(u),f(v)) \in E_{G_1}$ and $(f(u),f(v)) \in E_{G_2}$.

The MCS problem is known to be NP-hard, which implies that finding an efficient algorithm for solving it in the worst case is unlikely. Consequently, researchers have explored various heuristics, approximation algorithms, and exact methods for addressing the MCS problem, with varying levels of success.

\subsection{Quantum Computing}

Quantum computing is an emerging computational paradigm that exploits the principles of quantum mechanics to perform computations. Quantum computers use quantum bits, or qubits, as their fundamental building blocks. Unlike classical bits, which can be in a state of either 0 or 1, qubits can exist in a superposition of states, allowing them to represent multiple values simultaneously. This property enables quantum computers to perform parallel computations and potentially solve problems that are intractable for classical computers.

Quantum algorithms are designed to exploit the unique properties of quantum computing, such as superposition and entanglement, to perform computations more efficiently than classical algorithms. Some of the most well-known quantum algorithms include Shor's algorithm for integer factorization \cite{shor1994algorithms} and Grover's algorithm for unstructured search \cite{grover1996fast}.

\subsection{Grover's Algorithm}

Grover's algorithm is a well-known quantum search algorithm that provides a quadratic speedup for unstructured search tasks. The algorithm operates on a search space of size $N$, and its objective is to find an element $x$ such that $f(x)=1$, where $f$ is a function that takes an element from the search space and returns either 0 or 1. Grover's algorithm achieves this goal using a series of iterations, each consisting of two main steps: the application of an oracle function and a diffusion operation.

The oracle function, denoted $O_f$, is designed to recognize the target element $x$ such that $f(x)=1$. The oracle function acts on the input qubits and an additional ancillary qubit, flipping the sign of the ancillary qubit if the input qubits represent the target element. The diffusion operation is a global operation that amplifies the amplitude of the target element's state in the superposition of states, effectively increasing the probability of measuring the target element in the final state.

Grover's algorithm requires $O(\sqrt{N})$ iterations to find the target element with high probability, which is a significant speedup compared to classical unstructured search algorithms, which require $O(N)$ evaluations of the function $f$. This quadratic speedup has been applied to various combinatorial optimization problems, demonstrating the potential benefits of quantum computing for solving complex tasks.

% Rest of the paper


\section{Representation of R0 and R1}

In the context of the Maximum Common Subgraph (MCS) problem, R0 and R1 are used to represent the number of nodes in two different input graphs, say Graph A and Graph B, respectively. The MCS problem aims to find the largest subgraph that is common between the two input graphs. The algorithm we designed compares the values stored in R0 and R1 to determine if they form a valid solution to the MCS problem.

\section{Algorithm Overview}

Our algorithm is designed to be efficient and adheres to the constraints of the limited ARM processor. The assembly code we created follows a set of rules, such as using only the allowed instructions and avoiding loops, branches, and labels. Also, each register can only be used once, and a register cannot be used twice in an instruction.

The algorithm can be summarized in the following steps:

\begin{enumerate}
    \item Store the maximum allowed value (3) in a register (R2).
    \item Compare the values of R0 and R1 with R2, and store the results in two new registers (R3 and R4).
    \item Check if both R3 and R4 are greater than or equal to 0, indicating that R0 and R1 are within the allowed range.
    \item If both R3 and R4 are within the allowed range, perform a bitwise AND between them and store the result in a new register (R5).
    \item Compare the values of R0 and R1 and store the result in another register (R7).
    \item Set the ZERO flag in the Processor Status Register (PSR) if R0 and R1 are equal, and both are within the allowed range.
\end{enumerate}

\section{Algorithm Details and Steps}

\subsection{Storing the Maximum Allowed Value}

Since the maximum allowed value for our example is 3, we store this value in R2 using the MOV instruction. The MOV instruction copies the value of the second operand (immediate value 3) into the destination register (R2).

\subsection{Comparing R0 and R1 with the Maximum Allowed Value}

We compare the values of R0 and R1 with R2 (the maximum allowed value) by subtracting R2 from R0 and R1 using the SUB instruction. The results of these subtractions are stored in R3 and R4, respectively.

\subsection{Checking the Range of R0 and R1}

To check if R0 and R1 are within the allowed range, we perform a bitwise AND operation between R3 and R4 using the AND instruction. If both R3 and R4 are greater than or equal to 0, the result of the AND operation will be non-zero, indicating that R0 and R1 are within the allowed range. This result is stored in R5.

\subsection{Comparing R0 and R1}

We compare the values of R0 and R1 by subtracting R1 from R0 using the SUB instruction. The result of this subtraction is stored in R7.

\subsection{Setting the ZERO Flag}

Finally, we set the ZERO flag in the PSR if R0 and R1 are equal and both are within the allowed range. We use the TST instruction to test if R7, the result of the subtraction of R0 and R1, is zero. If it is, the ZERO flag is set to 1, indicating a valid solution to the MCS problem. If it is not, the ZERO flag is set to 0, indicating that R0 and R1 do not form a valid solution to the MCS problem.

\section{Conclusion}

The algorithm presented in this paper effectively determines whether the values stored in R0 and R1 form a valid solution to the Maximum Common Subgraph problem, while adhering to the constraints of a limited ARM processor. By using only the allowed instructions and following the specified rules, our algorithm efficiently compares the input values and sets the ZERO flag in the PSR accordingly. This approach can be useful in scenarios with limited computational resources or when optimizing for power consumption and execution time.



\section{Implementation}

The following program is an implementation of the above description. The created circuit is shown in Figure \ref{fig:Maximum_Common_Subgraph}:

\begin{lstlisting}

{"register_size": 2, "run": false, "display": false}
HAD R0
HAD R1

ORACLE


; Store the maximum allowed value (3) in R2
MOV R2, #3

; Compare R0 with R2 and store the result in R3
SUB R3, R2, R0

; Compare R1 with R2 and store the result in R4
SUB R4, R2, R1

; If both R3 and R4 are greater than or equal to 0, then R0 and R1 are within the allowed range
; Perform bitwise AND between R3 and R4, store the result in R5
AND R5, R3, R4

; Perform bitwise AND between R5 and the least significant bit of R5, store the result in R6
AND R6, R5, #1

; Compare R0 and R1 and store the result in R7
SUB R7, R0, R1

; Set the ZERO flag if R0 and R1 are equal and both are within the allowed range
; Calculate R7 AND R6, store the result in R8
AND R8, R7, R6

; Test if R8 is zero, set ZERO flag accordingly
TST R8, #0



END_ORACLE

TGT ZERO

REVERSE_ORACLE

DIF {R0, R1}

STR CR0, R0
STR CR1, R1


\end{lstlisting}

\begin{figure}[htp]
    \centering
    \includegraphics[width=9cm]{Figures/Maximum_Common_Subgraph_circuit.png}
    \caption{Using Grover's Algorithm to Solve the Maximum Common Subgraph Problem}
    \label{fig:Maximum_Common_Subgraph}
\end{figure}

\section{Conclusion}
\label{sec:conclusion}

In this paper, we have presented a novel quantum algorithm for solving the Maximum Common Subgraph (MCS) problem based on Grover's algorithm. By leveraging the powerful search capabilities of Grover's algorithm, our proposed method offers a potential quadratic speedup over classical approaches to the MCS problem. We provided a comprehensive description of the proposed algorithm, including the encoding of the MCS problem into a binary search space, the design of a suitable oracle function, and the integration of Grover's algorithm for efficient search. Furthermore, we conducted a theoretical analysis of the performance of our proposed algorithm, demonstrating its potential benefits and feasibility for solving the MCS problem in practice.

Our work contributes to the ongoing efforts to explore the potential of quantum computing for solving complex combinatorial optimization problems, particularly the MCS problem, which has significant applications in various domains. As quantum computing technology continues to advance, we expect that the efficiency and practicality of quantum algorithms for the MCS problem will further improve. Future research directions include exploring alternative problem encodings and oracle designs, as well as investigating hybrid quantum-classical approaches for solving the MCS problem. Additionally, the implementation and experimental evaluation of our proposed algorithm on real-world instances of the MCS problem using quantum simulators or actual quantum hardware will provide valuable insights into its practical performance and potential impact.


